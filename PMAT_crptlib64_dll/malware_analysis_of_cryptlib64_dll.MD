###### Author: Justin Powell
###### Date: April 22nd, 2023
###### Source of file: [PMAT course - TCM Academy](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs/3-4.StaySharp-CSharpMalware)

# Table of Contents
[Executive Summary](#es)<br>
[High-Level Technical Summary](#hlts)<br>
[Malware Composition](#mc)<br>
[Static Analysis](#sa)<br>
[dynamic Analysis](#da)<br>
[Indicators of Compromise](#ioc)<br>
[Signatures and Rules](#sar)<br>


# Executive Summary <a name="es"></a>
>sha256: 732F235784CD2A40C82847B4700FB73175221C6AE6C5F7200A3F43F209989387

The cryptlib64.dll file has various indicators of being a malicious piece of software. Upon execution, the user's device
will create new files, modify its own registry and begin contacting an external resource. Currently, it has only been 
observed sending data to that external resource. 

The sampled provided here is just the `.dll` file, whatever calls that file was not present to be analyzed during this
analysis.

The file has been flagged as malicious on [Virus Total](https://www.virustotal.com/gui/file/732f235784cd2a40c82847b4700fb73175221c6ae6c5f7200a3f43f209989387/detection)
and the same mechanisms have been observed herein.

Yara rules for detecting this software have been included. 

# High-Level Technical Summary <a name="hlts"></a>
The `.dll` file, once called up creates two files within the C:\Users\Public directory. 

The first is a Visual Basic Script which uses the second file (an XML file) to build another payload. 

The second payload has not, to this point, been decoded sufficiently to provide additional context on what it is capable 
of doing to host machine or network. It is clear, however, that upon calling the XML file, it's compressed, encoded block
of code contains instructions to at least contact an external server and to send it encrypted data. 

# Malware Composition <a name="mc"></a>
![comp](./Images/malware-composition.png)  
###### Figure 1: draw.io example of malware composition

# Static Analysis <a name="sa"></a>
### Floss
Analysis of the various strings within the dll show the encryption password used to obfuscate the XML file, potential file
names, additional dll names (though, these do not appear to get created)

Password String<br>
![strings](./Images/Static_Analysis/interesting-string-1.png)<br>
###### Figure 2: Password string for decrypting embed.xml 
<br>

Potential file names<br>
![file](./Images/Static_Analysis/potential-file-names.png)<br>
###### Figure 3: Strings from the binary which contain filenames
<br>

Seemingly unused dll names<br>
![dll](./Images/Static_Analysis/dll-strings.png)<br>
###### Figure 4: strings which contained "dll", but were never created on the filesystem
<br>

Greps for various strings, no http present, but clearly obfuscated later<br>
![grep](./Images/Static_Analysis/string-greps.png)<br>
###### Figure 5: grep results
<br>

### pestudio

Various C# imports are flagged for process injection, obfuscation, registry manipulation, file creation and cryptography

![imp](./Images/Static_Analysis/pestudio-imports.png)<br>
###### Figure 6: PEStudio imports
<br>

similar alarms are raised in the indicators section<br>
![ind](./Images/Static_Analysis/pestudio-indicators.png)<br>
###### Figure 7: PEStudio indicators
<br>

String analysis calls out the precesnce of base64 encoding, AES encryption and decryption and registry key manipulation.<br>
![str](./Images/Static_Analysis/pestudio-strings.png)<br>
###### Figure 8: PEStudio strings
<br>

### dnspy
Observation in dnspy shows that EmbedDLL was a namespace rather than a future persitence mechanism.<br>
A large encrypted and base64 encoded string contains all of the associated content for the XML file which is created by
this dll<br>
A seconds encoded string is present and will become a future VBS file. This content is decoded shortly.<br>
![1](./Images/Static_Analysis/dnspy-embed-function.png)<br>
![2](./Images/Static_Analysis/dnspy-first-string-to-embed_xml-then-next-to-embed_vbs.png)<br>
###### Figures 9 and 10: code shown in dnspy showing the creation of two files and a registry key
<br>

Focusing on the final section of this code, we see a try-catch where a registry key is to be created. This key is a run 
key, therefore each time the user logs in, it will run the vbs file. 
![3](./Images/Static_Analysis/regex-key-created-as-run.png)<br>
###### Figure 11: closer observation of the registry key block
<br>

Decoding the unencrypted base64 for the vbs script shows the contents of the script which will be created on execution.
![4](./Images/Static_Analysis/decoded-embed_vbs.png)<br>
###### Figure 12: decoded embed.vbs file which should be made upon running the DLL
<br>

So now we know that when the user logs in, the registry key will run the vbs file which will build something from the xml
file. 

This is a good time to migrate into dynamic analysis of this sample. 

# Dynamic Analysis <a name="da"></a>

After calling the `.dll` using `rundell32` we can see the files noted in `dnspy` are created.

![cml](./Images/Dynamic_Analysis/embed_xml_present.png)<br>
![vbs](./Images/Dynamic_Analysis/embed_vbs_present.png)<br>
###### Figures 13 and 14: Two files were created after calling the embed namespace within the dll
<br>
Checking for the registry key was also successful as shown here:

![reg](./Images/Dynamic_Analysis/registry-key.png)<br>
###### Figure 15: The registry key which was created
<br>
When we observe the .xml file that the .vbs file build, we can see a compressed base64 string.

![emb](./Images/Dynamic_Analysis/embed_xml_b64_mem_stream.png)<br>
###### Figure 16: Shows the base64 compressed string from embed.xml
<br>
I was unable to determine the compression method and successfully decompress this string.

However, calling the `.vbs` file, we can see a few things happen:
<br>Procmon shows a series of commands as the embeded.vbs file calls msbuild on the XML file.
![proc](./Images/Dynamic_Analysis/procmon.png)<br>
###### Figure 17: procmon output when calling embed.vbs
<br>

After building, we can see network traffic being generated<br>
![post](./Images/Dynamic_Analysis/post-request.png)<br>
###### Figure 18: Wireshark POST request when the embed.xml file is built <a name="f18"></a>
<br>

Here, we can see that this last stage does contain a http request. `hxxp://srv.mastercheifsgruntemporium.local`

Looking at the network traffic, we can see GET request being made to this site before the POST request ([Figure 18](#f18)) is made.

Analysis of the post request shows that it is base64 encoded and contains further obfuscated data within.

![pode](./Images/Dynamic_Analysis/post-message-decoded.png)<br>
###### Figure 19: decoded base64 from post request. HMAC sum is given as an encrypted message. Key and substance are unknown.

# Indicators of Compromise <a name="ioc"></a>
## Network Indicators:
> any network traffice to hxxp://srv.masterchiefsgruntemporium.local

## Host Indicators:
> precense of any of the following files:<br>
> C:\Users\Public\embed.xml<br>
> C:\Users\Public\Documents\embed.vbs<br>
> <br>
> Presence of the following registry key:<br>
> Computer\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run >> "embed" : "C:\Users\Public\Documents\embed.vbs"<br>


# Signatures and Rules <a name="sar"></a>
md5: 361E6EDB47E711A72C7F8EE3C0C1632B
sha256: 732F235784CD2A40C82847B4700FB73175221C6AE6C5F7200A3F43F209989387

In consideration for the strings present, The following yara rule has been created to detect this file
```python
rule crpytlib64_dll {
    meta:
        last_updated = "04-22-2023"
        author = "Justin Powell"
        description = "Ruleset for determining the presence of cryptlib64.dll infection"
        
    strings:
        $vbsindicator = "embed.vbs" wide
        $xmlindicator = "embed.xml" wide
        $csharpindicator = "Assembly Version" wide
        
    condition:
        $csharp-indicator and
        ($vbs-indicator or $xml-indicator)
         
}
```

Running that yara rule in the Desktop for the analysis user shows a positive indication only on appropriate file

![proof](./Images/proof-of-yara.png)<>
###### Figure 20: Evidence of successful use of yara rule